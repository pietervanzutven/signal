'use strict';

(function () {
    const storage = Windows.Storage;
    const fileIO = storage.FileIO;
    const localFolder = storage.ApplicationData.current.localFolder;

    const { app } = window.electron;

    window.fs_extra = {
        constants: { F_OK: 0 },
        access: async (filePath) => {
            let item = localFolder;
            const pathParts = filePath.replace('ms-appdata:///local/','').split('/');
            for (let i = 0; i < pathParts.length; i++) {
                item = await item.getItemAsync(pathParts[i]);
            }
            return item;
        },
        ensureDir: async (directoryPath) => {
            var uri = new Windows.Foundation.Uri(directoryPath);
            let folder = localFolder;
            const pathParts = uri.absoluteUri.replace(app.getPath(),'').replace('file:///','').split('/').filter(element => element !== '');
            for (let i = 0; i < pathParts.length; i++) {
                folder = await folder.createFolderAsync(pathParts[i], Windows.Storage.CreationCollisionOption.openIfExists);
            }
            return folder;
        },
        emptyDir: async (directoryPath) => {
            const folder = await window.fs_extra.ensureDir(directoryPath);
            folder.deleteAsync();
            await window.fs_extra.ensureDir(directoryPath);
        },
        ensureFile: async (filePath) => {
            let fileName, folder;
            if (filePath.includes('/')) {
                const pathParts = filePath.split('/');
                fileName = pathParts.pop();
                folder = await window.fs_extra.ensureDir(pathParts.join('/'));
            } else {
                fileName = filePath;
                folder = localFolder;
            }
            return await folder.createFileAsync(fileName, Windows.Storage.CreationCollisionOption.openIfExists);
        },
        readFile: async (filePath) => {
            const file = await window.fs_extra.ensureFile(filePath);
            const buffer = await fileIO.readBufferAsync(file);
            return Windows.Security.Cryptography.CryptographicBuffer.copyToByteArray(buffer);
        },
        writeFile: async (filePath, buffer) => {
            const mru = Windows.Storage.AccessCache.StorageApplicationPermissions.mostRecentlyUsedList;
            const entry = mru.entries.first();
            let file;
            if (entry.hasCurrent && entry.current.metadata === filePath) {
                file = await mru.getFileAsync(entry.current.token);
            } else {
                file = await window.fs_extra.ensureFile(filePath);
            }
            const data = new Uint8Array(buffer.bytebuffer.toBuffer());
            await fileIO.writeBytesAsync(file, data);
        },
        remove: async (filePath) => {
            const file = await window.fs_extra.ensureFile(filePath);
            await file.deleteAsync();
        },
        realpath: async (path) => path,
    }
})();