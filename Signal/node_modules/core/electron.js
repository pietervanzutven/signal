(function () {
    'use strict';

    const viewManagement = Windows.UI.ViewManagement;

    window.electron = {
        app: {
            getVersion: () => {
                const version = Windows.ApplicationModel.Package.current.id.version;
                return version.major + '.' + version.minor + '.' + version.build
            },
            getPath: () => 'ms-appdata:///local',
            setAppUserModelId: () => { },
            getLocale: () => Windows.Globalization.ApplicationLanguages.languages[0],
            require: () => {
                return {
                    systemPreferences: {
                        isDarkMode: () => viewManagement.UISettings().getColorValue(viewManagement.UIColorType.background).b === 255
                    }
                }
            }
        },

        BrowserWindow(options) {
            this.callbacks = {};
            this.on = (name, callback) => this.callbacks[name] = callback;
            this.once = (name, callback) => this.callbacks[name] = callback;
            this.loadURL = url => {
                window.document.body.appendChild(this.frame);
                this.frame.onload = () => {
                    if (this.callbacks['ready-to-show']) {
                        this.callbacks['ready-to-show']();
                    }
                };
                this.frame.src = url.replace('file:///', '');
            }
            this.show = () => {
                this.frame.style.visibility = 'visible';
                if (this.closeButton) {
                    window.document.body.appendChild(this.closeButton);
                }
            }
            this.close = () => {
                if (this.closeButton) {
                    document.body.removeChild(this.closeButton);
                }
                if (this.frame) {
                    document.body.removeChild(this.frame);
                }
                if (this.callbacks['closed']) {
                    this.callbacks['closed']();
                }
            }
        
            if (options) {
                this.width = Math.min(window.innerWidth, options.width);
                this.height = Math.min(window.innerHeight, options.height);
        
                this.frame = document.createElement('iframe');
                this.frame.style.position = 'absolute';
                this.frame.style.top = 'calc(50% - ' + this.height / 2 + 'px)';
                this.frame.style.left = 'calc(50% - ' + this.width / 2 + 'px)';
                this.frame.style.height = this.height + 'px';
                this.frame.style.width = this.width + 'px';
                this.frame.style.zIndex = '500';
                this.frame.style.border = 'none';
                this.frame.style.visibility = 'hidden';
            }
        
            if (options && !options.modal) {
                this.closeButton = document.createElement('a');
                this.closeButton.className = 'x close';
                this.closeButton.href = '#';
                this.closeButton.style.position = 'absolute';
                this.closeButton.style.top = 'calc(50% - ' + (this.height / 2 - 10) + 'px)';
                this.closeButton.style.left = 'calc(50% + ' + (this.width / 2 - 30) + 'px)';
                this.closeButton.style.zIndex = '1000';
                this.closeButton.onclick = this.close;
            }
        
            this.getSize = () => [window.innerWidth, window.innerHeight];
            this.setAutoHideMenuBar = () => { };
            this.setMenuBarVisibility = () => { };
            this.webContents = window.electron.ipc;
        },

        ipc: {
            events: {},
            on: function (channel, listener) {
                ipc.events[channel] = listener;
            },

            once: function (channel, listener) {
                ipc.events[channel] = function () {
                    listener.apply(null, arguments);
                    delete ipc.events[channel];
                }
            },
            send: function () {
                let args = Array.prototype.slice.call(arguments, 0);
                const channel = args[0];
                const event = { channel: channel, returnValue: null, sender: { send: ipc.send } };
                args[0] = event;
                ipc.events[channel].apply(null, args);
                return event.returnValue;
            },
            sendSync: function () {
                return ipc.send.apply(null, arguments);
            },
            setMaxListeners: function () { }
        },

        Menu: { },

        protocol: { }, 

        session: { },

        shell: { },

        systemPreferences: { isDarkMode: () => viewManagement.UISettings().getColorValue(viewManagement.UIColorType.background).b !== 255 },

        require: () => window.electron,
    };

    window.electron.ipcRenderer = window.electron.ipc;
    window.electron.ipcMain = window.electron.ipc;
    
    window.electron.remote = window.electron;
})();